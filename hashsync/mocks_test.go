// Code generated by MockGen. DO NOT EDIT.
// Source: ./interface.go
//
// Generated by this command:
//
//	mockgen -typed -package=hashsync -destination=./mocks_test.go -source=./interface.go
//

// Package hashsync is a generated GoMock package.
package hashsync

import (
	context "context"
	reflect "reflect"

	types "github.com/spacemeshos/go-spacemesh/common/types"
	p2p "github.com/spacemeshos/go-spacemesh/p2p"
	server "github.com/spacemeshos/go-spacemesh/p2p/server"
	gomock "go.uber.org/mock/gomock"
)

// Mockrequester is a mock of requester interface.
type Mockrequester struct {
	ctrl     *gomock.Controller
	recorder *MockrequesterMockRecorder
}

// MockrequesterMockRecorder is the mock recorder for Mockrequester.
type MockrequesterMockRecorder struct {
	mock *Mockrequester
}

// NewMockrequester creates a new mock instance.
func NewMockrequester(ctrl *gomock.Controller) *Mockrequester {
	mock := &Mockrequester{ctrl: ctrl}
	mock.recorder = &MockrequesterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockrequester) EXPECT() *MockrequesterMockRecorder {
	return m.recorder
}

// Run mocks base method.
func (m *Mockrequester) Run(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Run indicates an expected call of Run.
func (mr *MockrequesterMockRecorder) Run(arg0 any) *MockrequesterRunCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*Mockrequester)(nil).Run), arg0)
	return &MockrequesterRunCall{Call: call}
}

// MockrequesterRunCall wrap *gomock.Call
type MockrequesterRunCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockrequesterRunCall) Return(arg0 error) *MockrequesterRunCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockrequesterRunCall) Do(f func(context.Context) error) *MockrequesterRunCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockrequesterRunCall) DoAndReturn(f func(context.Context) error) *MockrequesterRunCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StreamRequest mocks base method.
func (m *Mockrequester) StreamRequest(arg0 context.Context, arg1 p2p.Peer, arg2 []byte, arg3 server.StreamRequestCallback, arg4 ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "StreamRequest", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// StreamRequest indicates an expected call of StreamRequest.
func (mr *MockrequesterMockRecorder) StreamRequest(arg0, arg1, arg2, arg3 any, arg4 ...any) *MockrequesterStreamRequestCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1, arg2, arg3}, arg4...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StreamRequest", reflect.TypeOf((*Mockrequester)(nil).StreamRequest), varargs...)
	return &MockrequesterStreamRequestCall{Call: call}
}

// MockrequesterStreamRequestCall wrap *gomock.Call
type MockrequesterStreamRequestCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockrequesterStreamRequestCall) Return(arg0 error) *MockrequesterStreamRequestCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockrequesterStreamRequestCall) Do(f func(context.Context, p2p.Peer, []byte, server.StreamRequestCallback, ...string) error) *MockrequesterStreamRequestCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockrequesterStreamRequestCall) DoAndReturn(f func(context.Context, p2p.Peer, []byte, server.StreamRequestCallback, ...string) error) *MockrequesterStreamRequestCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockpeerSet is a mock of peerSet interface.
type MockpeerSet struct {
	ctrl     *gomock.Controller
	recorder *MockpeerSetMockRecorder
}

// MockpeerSetMockRecorder is the mock recorder for MockpeerSet.
type MockpeerSetMockRecorder struct {
	mock *MockpeerSet
}

// NewMockpeerSet creates a new mock instance.
func NewMockpeerSet(ctrl *gomock.Controller) *MockpeerSet {
	mock := &MockpeerSet{ctrl: ctrl}
	mock.recorder = &MockpeerSetMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockpeerSet) EXPECT() *MockpeerSetMockRecorder {
	return m.recorder
}

// addPeer mocks base method.
func (m *MockpeerSet) addPeer(p p2p.Peer) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "addPeer", p)
}

// addPeer indicates an expected call of addPeer.
func (mr *MockpeerSetMockRecorder) addPeer(p any) *MockpeerSetaddPeerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "addPeer", reflect.TypeOf((*MockpeerSet)(nil).addPeer), p)
	return &MockpeerSetaddPeerCall{Call: call}
}

// MockpeerSetaddPeerCall wrap *gomock.Call
type MockpeerSetaddPeerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockpeerSetaddPeerCall) Return() *MockpeerSetaddPeerCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockpeerSetaddPeerCall) Do(f func(p2p.Peer)) *MockpeerSetaddPeerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockpeerSetaddPeerCall) DoAndReturn(f func(p2p.Peer)) *MockpeerSetaddPeerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// havePeer mocks base method.
func (m *MockpeerSet) havePeer(p p2p.Peer) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "havePeer", p)
	ret0, _ := ret[0].(bool)
	return ret0
}

// havePeer indicates an expected call of havePeer.
func (mr *MockpeerSetMockRecorder) havePeer(p any) *MockpeerSethavePeerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "havePeer", reflect.TypeOf((*MockpeerSet)(nil).havePeer), p)
	return &MockpeerSethavePeerCall{Call: call}
}

// MockpeerSethavePeerCall wrap *gomock.Call
type MockpeerSethavePeerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockpeerSethavePeerCall) Return(arg0 bool) *MockpeerSethavePeerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockpeerSethavePeerCall) Do(f func(p2p.Peer) bool) *MockpeerSethavePeerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockpeerSethavePeerCall) DoAndReturn(f func(p2p.Peer) bool) *MockpeerSethavePeerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// listPeers mocks base method.
func (m *MockpeerSet) listPeers() []p2p.Peer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "listPeers")
	ret0, _ := ret[0].([]p2p.Peer)
	return ret0
}

// listPeers indicates an expected call of listPeers.
func (mr *MockpeerSetMockRecorder) listPeers() *MockpeerSetlistPeersCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "listPeers", reflect.TypeOf((*MockpeerSet)(nil).listPeers))
	return &MockpeerSetlistPeersCall{Call: call}
}

// MockpeerSetlistPeersCall wrap *gomock.Call
type MockpeerSetlistPeersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockpeerSetlistPeersCall) Return(arg0 []p2p.Peer) *MockpeerSetlistPeersCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockpeerSetlistPeersCall) Do(f func() []p2p.Peer) *MockpeerSetlistPeersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockpeerSetlistPeersCall) DoAndReturn(f func() []p2p.Peer) *MockpeerSetlistPeersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// numPeers mocks base method.
func (m *MockpeerSet) numPeers() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "numPeers")
	ret0, _ := ret[0].(int)
	return ret0
}

// numPeers indicates an expected call of numPeers.
func (mr *MockpeerSetMockRecorder) numPeers() *MockpeerSetnumPeersCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "numPeers", reflect.TypeOf((*MockpeerSet)(nil).numPeers))
	return &MockpeerSetnumPeersCall{Call: call}
}

// MockpeerSetnumPeersCall wrap *gomock.Call
type MockpeerSetnumPeersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockpeerSetnumPeersCall) Return(arg0 int) *MockpeerSetnumPeersCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockpeerSetnumPeersCall) Do(f func() int) *MockpeerSetnumPeersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockpeerSetnumPeersCall) DoAndReturn(f func() int) *MockpeerSetnumPeersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// removePeer mocks base method.
func (m *MockpeerSet) removePeer(p p2p.Peer) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "removePeer", p)
}

// removePeer indicates an expected call of removePeer.
func (mr *MockpeerSetMockRecorder) removePeer(p any) *MockpeerSetremovePeerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "removePeer", reflect.TypeOf((*MockpeerSet)(nil).removePeer), p)
	return &MockpeerSetremovePeerCall{Call: call}
}

// MockpeerSetremovePeerCall wrap *gomock.Call
type MockpeerSetremovePeerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockpeerSetremovePeerCall) Return() *MockpeerSetremovePeerCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockpeerSetremovePeerCall) Do(f func(p2p.Peer)) *MockpeerSetremovePeerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockpeerSetremovePeerCall) DoAndReturn(f func(p2p.Peer)) *MockpeerSetremovePeerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MocksyncBase is a mock of syncBase interface.
type MocksyncBase struct {
	ctrl     *gomock.Controller
	recorder *MocksyncBaseMockRecorder
}

// MocksyncBaseMockRecorder is the mock recorder for MocksyncBase.
type MocksyncBaseMockRecorder struct {
	mock *MocksyncBase
}

// NewMocksyncBase creates a new mock instance.
func NewMocksyncBase(ctrl *gomock.Controller) *MocksyncBase {
	mock := &MocksyncBase{ctrl: ctrl}
	mock.recorder = &MocksyncBaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocksyncBase) EXPECT() *MocksyncBaseMockRecorder {
	return m.recorder
}

// derive mocks base method.
func (m *MocksyncBase) derive(p p2p.Peer) syncer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "derive", p)
	ret0, _ := ret[0].(syncer)
	return ret0
}

// derive indicates an expected call of derive.
func (mr *MocksyncBaseMockRecorder) derive(p any) *MocksyncBasederiveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "derive", reflect.TypeOf((*MocksyncBase)(nil).derive), p)
	return &MocksyncBasederiveCall{Call: call}
}

// MocksyncBasederiveCall wrap *gomock.Call
type MocksyncBasederiveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocksyncBasederiveCall) Return(arg0 syncer) *MocksyncBasederiveCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocksyncBasederiveCall) Do(f func(p2p.Peer) syncer) *MocksyncBasederiveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocksyncBasederiveCall) DoAndReturn(f func(p2p.Peer) syncer) *MocksyncBasederiveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// probe mocks base method.
func (m *MocksyncBase) probe(ctx context.Context, p p2p.Peer) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "probe", ctx, p)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// probe indicates an expected call of probe.
func (mr *MocksyncBaseMockRecorder) probe(ctx, p any) *MocksyncBaseprobeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "probe", reflect.TypeOf((*MocksyncBase)(nil).probe), ctx, p)
	return &MocksyncBaseprobeCall{Call: call}
}

// MocksyncBaseprobeCall wrap *gomock.Call
type MocksyncBaseprobeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocksyncBaseprobeCall) Return(arg0 int, arg1 error) *MocksyncBaseprobeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocksyncBaseprobeCall) Do(f func(context.Context, p2p.Peer) (int, error)) *MocksyncBaseprobeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocksyncBaseprobeCall) DoAndReturn(f func(context.Context, p2p.Peer) (int, error)) *MocksyncBaseprobeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Mocksyncer is a mock of syncer interface.
type Mocksyncer struct {
	ctrl     *gomock.Controller
	recorder *MocksyncerMockRecorder
}

// MocksyncerMockRecorder is the mock recorder for Mocksyncer.
type MocksyncerMockRecorder struct {
	mock *Mocksyncer
}

// NewMocksyncer creates a new mock instance.
func NewMocksyncer(ctrl *gomock.Controller) *Mocksyncer {
	mock := &Mocksyncer{ctrl: ctrl}
	mock.recorder = &MocksyncerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mocksyncer) EXPECT() *MocksyncerMockRecorder {
	return m.recorder
}

// peer mocks base method.
func (m *Mocksyncer) peer() p2p.Peer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "peer")
	ret0, _ := ret[0].(p2p.Peer)
	return ret0
}

// peer indicates an expected call of peer.
func (mr *MocksyncerMockRecorder) peer() *MocksyncerpeerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "peer", reflect.TypeOf((*Mocksyncer)(nil).peer))
	return &MocksyncerpeerCall{Call: call}
}

// MocksyncerpeerCall wrap *gomock.Call
type MocksyncerpeerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocksyncerpeerCall) Return(arg0 p2p.Peer) *MocksyncerpeerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocksyncerpeerCall) Do(f func() p2p.Peer) *MocksyncerpeerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocksyncerpeerCall) DoAndReturn(f func() p2p.Peer) *MocksyncerpeerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// sync mocks base method.
func (m *Mocksyncer) sync(ctx context.Context, x, y *types.Hash32) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "sync", ctx, x, y)
	ret0, _ := ret[0].(error)
	return ret0
}

// sync indicates an expected call of sync.
func (mr *MocksyncerMockRecorder) sync(ctx, x, y any) *MocksyncersyncCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "sync", reflect.TypeOf((*Mocksyncer)(nil).sync), ctx, x, y)
	return &MocksyncersyncCall{Call: call}
}

// MocksyncersyncCall wrap *gomock.Call
type MocksyncersyncCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocksyncersyncCall) Return(arg0 error) *MocksyncersyncCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocksyncersyncCall) Do(f func(context.Context, *types.Hash32, *types.Hash32) error) *MocksyncersyncCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocksyncersyncCall) DoAndReturn(f func(context.Context, *types.Hash32, *types.Hash32) error) *MocksyncersyncCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
